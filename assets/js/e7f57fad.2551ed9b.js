"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3232],{1477:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"configuration_deployment/advanced_configuration","title":"Advanced Configuration","description":"Docker login for private registry","source":"@site/docs/3_configuration_deployment/9_advanced_configuration.md","sourceDirName":"3_configuration_deployment","slug":"/configuration_deployment/advanced_configuration","permalink":"/casskop/docs/configuration_deployment/advanced_configuration","draft":false,"unlisted":false,"editUrl":"https://github.com/cscetbon/casskop/edit/master/website/docs/3_configuration_deployment/9_advanced_configuration.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"title":"Advanced Configuration","sidebar_label":"Advanced Configuration"},"sidebar":"docs","previous":{"title":"Sidecars","permalink":"/casskop/docs/configuration_deployment/sidecars"},"next":{"title":"Nodes Management","permalink":"/casskop/docs/configuration_deployment/nodes_management"}}');var r=n(4848),t=n(8453);const o={title:"Advanced Configuration",sidebar_label:"Advanced Configuration"},i=void 0,c={},d=[{value:"Docker login for private registry",id:"docker-login-for-private-registry",level:2},{value:"Management of allowed Cassandra nodes disruption",id:"management-of-allowed-cassandra-nodes-disruption",level:2},{value:"Cross Ip Management",id:"cross-ip-management",level:2},{value:"Global mecanism",id:"global-mecanism",level:3},{value:"Ip Cross situation detection",id:"ip-cross-situation-detection",level:2}];function l(e){const a={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.h2,{id:"docker-login-for-private-registry",children:"Docker login for private registry"}),"\n",(0,r.jsx)(a.p,{children:"If you need to use a docker registry with authentication, then you will need to create a specific kubernetes secret with\nthis information.\nThen you will configure the CRD with the secret name, so that it provides the data to each Statefulset, which in\nturn propagate it to each created Pod."}),"\n",(0,r.jsx)(a.p,{children:"Create the secret :"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-bash",children:"kubectl create secret docker-registry yoursecretname \\\n  --docker-server=yourdockerregistry\n  --docker-username=yourlogin \\\n  --docker-password=yourpass \\\n  --docker-email=yourloginemail\n"})}),"\n",(0,r.jsxs)(a.p,{children:["Then we will add a ",(0,r.jsx)(a.strong,{children:"imagePullSecrets"})," parameter in the CRD definition with value the name of the\npreviously created secret. You can give several secrets :"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-yaml",children:"imagePullSecrets:\n  name: yoursecretname\n"})}),"\n",(0,r.jsx)(a.h2,{id:"management-of-allowed-cassandra-nodes-disruption",children:"Management of allowed Cassandra nodes disruption"}),"\n",(0,r.jsx)(a.p,{children:"CassKop makes use of the kubernetes PodDisruptionBudget objetc to specify how many cassandra nodes disruption is\nallowed on the cluster. By default, we only tolerate 1 disrupted pod at a time and will prevent to makes actions if\nthere is aloready an ongling disruption on the cluster."}),"\n",(0,r.jsxs)(a.p,{children:["In some edge cases it can be useful to make force the operator to continue it's actions even if there is already a\ndisruption ongoing. We can tune this by updating the ",(0,r.jsx)(a.code,{children:"spec.maxPodUnavailable"})," parameter of the cassandracluster CRD."]}),"\n",(0,r.jsx)(a.admonition,{type:"important",children:(0,r.jsx)(a.p,{children:"it is recommended to not touch this parameter unless you know what you are doing."})}),"\n",(0,r.jsx)(a.h2,{id:"cross-ip-management",children:"Cross Ip Management"}),"\n",(0,r.jsx)(a.h3,{id:"global-mecanism",children:"Global mecanism"}),"\n",(0,r.jsx)(a.p,{children:"Cassandra works on IPs and not on hostname, so in a case where two cassandra cross their Ips, no Cassandra will be able to run properly and will loop on the following error :"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-log",children:"cassandra Exception (java.lang.RuntimeException) encountered during startup: A node with address /10.100.150.35 already exists, cancelling join. Use cassandra.replace_address if you want to replace this node.\ncassandra java.lang.RuntimeException: A node with address /10.100.150.35 already exists, cancelling join. Use cassandra.replace_address if you want to replace this node.\ncassandra     at org.apache.cassandra.service.StorageService.checkForEndpointCollision(StorageService.java:577)\ncassandra     at org.apache.cassandra.service.StorageService.prepareToJoin(StorageService.java:823)\ncassandra     at org.apache.cassandra.service.StorageService.initServer(StorageService.java:683)\ncassandra     at org.apache.cassandra.service.StorageService.initServer(StorageService.java:632)\ncassandra     at org.apache.cassandra.service.CassandraDaemon.setup(CassandraDaemon.java:388)\ncassandra     at org.apache.cassandra.service.CassandraDaemon.activate(CassandraDaemon.java:620)\ncassandra     at org.apache.cassandra.service.CassandraDaemon.main(CassandraDaemon.java:732)\ncassandra ERROR [main] 2020-02-21 08:29:44,398 CassandraDaemon.java:749 - Exception encountered during startup\ncassandra java.lang.RuntimeException: A node with address /10.100.150.35 already exists, cancelling join. Use cassandra.replace_address if you want to replace this node.\ncassandra     at org.apache.cassandra.service.StorageService.checkForEndpointCollision(StorageService.java:577) ~[apache-cassandra-3.11.4.jar:3.11.4]\ncassandra     at org.apache.cassandra.service.StorageService.prepareToJoin(StorageService.java:823) ~[apache-cassandra-3.11.4.jar:3.11.4]\ncassandra     at org.apache.cassandra.service.StorageService.initServer(StorageService.java:683) ~[apache-cassandra-3.11.4.jar:3.11.4]\ncassandra     at org.apache.cassandra.service.StorageService.initServer(StorageService.java:632) ~[apache-cassandra-3.11.4.jar:3.11.4]\ncassandra     at org.apache.cassandra.service.CassandraDaemon.setup(CassandraDaemon.java:388) [apache-cassandra-3.11.4.jar:3.11.4]\ncassandra     at org.apache.cassandra.service.CassandraDaemon.activate(CassandraDaemon.java:620) [apache-cassandra-3.11.4.jar:3.11.4]\ncassandra     at org.apache.cassandra.service.CassandraDaemon.main(CassandraDaemon.java:732) [apache-cassandra-3.11.4.jar:3.11.4]\n"})}),"\n",(0,r.jsxs)(a.p,{children:["Following the ",(0,r.jsx)(a.a,{href:"https://github.com/cscetbon/casskop/issues/170",children:"issue #170"}),", at least using Kubernetes and ",(0,r.jsx)(a.a,{href:"https://docs.projectcalico.org/v3.9/getting-started/kubernetes/",children:"Project Calico"}),", we may fall into this issue,\nfor example using a fixed ",(0,r.jsx)(a.a,{href:"https://docs.projectcalico.org/v3.9/reference/resources/ippool",children:"ip pool"})," size."]}),"\n",(0,r.jsxs)(a.p,{children:["To manage this case we introduced the ",(0,r.jsx)(a.code,{children:"restartCountBeforePodDeletion"})," CassandraCluster spec field which takes an ",(0,r.jsx)(a.code,{children:"int32"})," as value."]}),"\n",(0,r.jsx)(a.admonition,{type:"note",children:(0,r.jsx)(a.p,{children:"If you set it with a value lower or equals to 0, or if you omit it, no action will be performed"})}),"\n",(0,r.jsxs)(a.p,{children:["In setting this field, the cassandra operator will check for each ",(0,r.jsx)(a.code,{children:"CassandraCluster"})," if a pod is in a restart situation (based on restart count of the cassandra container inside the pod).\nIn the case where the restartCount of the pod is greater than the value of ",(0,r.jsx)(a.code,{children:"restartCountBeforePodDeletion"})," field and if we are in a Ip cross situation, we will delete the pod, which will be recreated by the Statefulset.\nIn the case of Project Calico usage, this force the pod to get another available IP, which fixes our bug."]}),"\n",(0,r.jsx)(a.h2,{id:"ip-cross-situation-detection",children:"Ip Cross situation detection"}),"\n",(0,r.jsxs)(a.p,{children:["To detect that we are in a Ip cross situation, we add a new status field ",(0,r.jsx)(a.code,{children:"CassandraNodeStatus"})," which will maintain a cache about the map of ",(0,r.jsx)(a.em,{children:"Ip node"})," and his ",(0,r.jsx)(a.em,{children:"hostId"}),",\nfor all ready pods."]}),"\n",(0,r.jsx)(a.admonition,{type:"note",children:(0,r.jsxs)(a.p,{children:["to have more information about this status field, you can check ",(0,r.jsx)(a.a,{href:"#cassandracluster-status",children:"CassandraCluster Status"})]})}),"\n",(0,r.jsxs)(a.p,{children:["So when we check pods, we perform a Jolokia call to get a map of the cluster nodes IPs with their corresponding HostId.\nIf a pod is failing with the constraints described above, we compare the hostId associated to the Pod's IP, and the hostId\nassociated to the Pod name stored into the ",(0,r.jsx)(a.code,{children:"CassandraNodeStatus"})," :"]}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsx)(a.li,{children:"if they match, or there are no match for the pod Ip into the map returned by Jolokia, we are not in a Ip cross situation,"}),"\n",(0,r.jsx)(a.li,{children:"if they mismatch, we are in a Ip cross situation."}),"\n"]})]})}function h(e={}){const{wrapper:a}={...(0,t.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>o,x:()=>i});var s=n(6540);const r={},t=s.createContext(r);function o(e){const a=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:a},e.children)}}}]);