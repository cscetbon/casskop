"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4804],{8406:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var t=n(5893),i=n(1151);const o={title:"Nodes Management",sidebar_label:"Nodes Management"},r=void 0,a={id:"configuration_deployment/nodes_management",title:"Nodes Management",description:"CassKop in duo with the Cassandra docker Image is responsible of the lifecycle of the Cassandra nodes.",source:"@site/docs/3_configuration_deployment/10_nodes_management.md",sourceDirName:"3_configuration_deployment",slug:"/configuration_deployment/nodes_management",permalink:"/casskop/docs/configuration_deployment/nodes_management",draft:!1,unlisted:!1,editUrl:"https://github.com/cscetbon/casskop/edit/master/website/docs/3_configuration_deployment/10_nodes_management.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{title:"Nodes Management",sidebar_label:"Nodes Management"},sidebar:"docs",previous:{title:"Advanced Configuration",permalink:"/casskop/docs/configuration_deployment/advanced_configuration"},next:{title:"CassandraCluster Status",permalink:"/casskop/docs/configuration_deployment/cassandra_cluster_status"}},c={},d=[{value:"HealthChecks",id:"healthchecks",level:2},{value:"Prometheus metrics export",id:"prometheus-metrics-export",level:2}];function l(e){const s={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:"CassKop in duo with the Cassandra docker Image is responsible of the lifecycle of the Cassandra nodes."}),"\n",(0,t.jsx)(s.h2,{id:"healthchecks",children:"HealthChecks"}),"\n",(0,t.jsx)(s.p,{children:"Healthchecks are periodical tests which verify Cassandra's health. When the healthcheck fails, Kubernetes can assume\nthat the application is not healthy and attempt to fix it. Kubernetes supports two types of Healthcheck probes :"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Liveness probes"}),"\n",(0,t.jsx)(s.li,{children:"Readiness probes."}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["You can find more details in the ",(0,t.jsx)(s.a,{href:"https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes",children:"Kubernetes\ndocumentation"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["Both ",(0,t.jsx)(s.code,{children:"livenessProbe"})," and ",(0,t.jsx)(s.code,{children:"readinessProbe"})," support two additional options:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"initialDelaySeconds"}),": defines the initial delay before the probe is tried for the first time. Default is 15 seconds"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"timeoutSeconds"}),": defines the timeout of the probe. CassKop uses 20 seconds."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"periodSeconds"}),": the period to wait between each call to a probe: CassKop uses 40 seconds."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["You are now able to override this default values using the following fields in to the ",(0,t.jsx)(s.code,{children:"CassandraCluster"})," definition :"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"livenessInitialDelaySeconds"}),": defines initial delay for the liveness probe of the main"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"livenessHealthCheckTimeout"}),": defines health check timeout for the liveness probe of the main"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"livenessHealthCheckPeriod"}),": defines health check period for the liveness probe of the main"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"livenessFailureThreshold"}),": defines failure threshold for the liveness probe of the main"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"livenessSuccessThreshold"}),": defines success threshold for the liveness probe of the main"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"readinessInitialDelaySeconds"}),": defines initial delay for the readiness probe of the main"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"readinessHealthCheckTimeout"}),": defines health check timeout for the readiness probe of the main"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"readinessHealthCheckPeriod"}),": defines health check period for the readiness probe of the main"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"readinessFailureThreshold"}),": defines failure threshold for the readiness probe of the main"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"readinessSuccessThreshold"}),": defines success threshold for the readiness probe of the main"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"prometheus-metrics-export",children:"Prometheus metrics export"}),"\n",(0,t.jsx)(s.p,{children:"We currently use the CoreOS Prometheus Operator to export the Cassandra nodes metrics. We must create a serviceMonitor\nobject in the prometheus namespaces, pointing to the exporter-prometheus-service which is created by CassKop:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-yaml",children:"$ cat config/samples/prometheus-cassandra-service-monitor.yaml\napiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: prometheus-cassandra-jmx\n  labels:\n    k8s-apps: cassandra-k8s-jmx\n    prometheus: kube-prometheus\n    component: cassandra\n    app: cassandra\nspec:\n  jobLabel: kube-prometheus-cassandra-k8s-jmx\n  selector:\n    matchLabels:\n      k8s-app: exporter-cassandra-jmx\n  namespaceSelector:\n      matchNames:\n      - cassandra\n      - cassandra-demo\n  endpoints:\n  - port: promjmx\n    interval: 15s\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Actually the Cassandra nodes use the work of Oleg Glusahak ",(0,t.jsx)(s.a,{href:"https://github.com/oleg-glushak/cassandra-prometheus-jmx",children:"https://github.com/oleg-glushak/cassandra-prometheus-jmx"})," but\nthis may change in the futur."]})]})}function h(e={}){const{wrapper:s}={...(0,i.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},1151:(e,s,n)=>{n.d(s,{Z:()=>a,a:()=>r});var t=n(7294);const i={},o=t.createContext(i);function r(e){const s=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:s},e.children)}}}]);